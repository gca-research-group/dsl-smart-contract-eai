/*
 * generated by Xtext 2.28.0
 */
package br.edu.unijui.gca.jabuti.generator

import br.edu.unijui.gca.jabuti.jabuti.BinaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.BinaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Contract
import br.edu.unijui.gca.jabuti.jabuti.DataType
import br.edu.unijui.gca.jabuti.jabuti.Expression
import br.edu.unijui.gca.jabuti.jabuti.MaxNumberOfOperation
import br.edu.unijui.gca.jabuti.jabuti.MessageContent
import br.edu.unijui.gca.jabuti.jabuti.NumericValue
import br.edu.unijui.gca.jabuti.jabuti.StringValue
import br.edu.unijui.gca.jabuti.jabuti.Term
import br.edu.unijui.gca.jabuti.jabuti.VariableValue
import java.util.HashSet

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.edu.unijui.gca.jabuti.jabuti.LiteralValue
import br.edu.unijui.gca.jabuti.jabuti.UnaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Variable
import br.edu.unijui.gca.jabuti.jabuti.ParenthesizedExpression
import br.edu.unijui.gca.jabuti.jabuti.ExpressionTerm
import br.edu.unijui.gca.jabuti.jabuti.UnaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.Timeout
import br.edu.unijui.gca.jabuti.jabuti.TimeInterval
import br.edu.unijui.gca.jabuti.jabuti.WeekDaysInterval
import br.edu.unijui.gca.jabuti.jabuti.SessionInterval
import br.edu.unijui.gca.jabuti.jabuti.ConditionalExpression
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JabutiGenerator extends AbstractGenerator {

//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//	}
	static var comparison_symbols = newArrayList
	static var logical_symbols = newArrayList
	static var math_symbols = newArrayList
	static var unary_symbols = newArrayList
	static var variables_map = newHashMap
	static var dataTypesIntoTheExpression = newArrayList
	static var symbolsIntoTheExpression = newArrayList

	//static var usedTermsTypeInBlockTerms = newHashSet

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (c : resource.allContents.filter(Contract).toIterable) {
			fsa.generateFile(c.name + '.sol', generateSolCode(c))
		}

	}

	def generateSolCode(Contract ct) {

		comparison_symbols.addAll(#["<=", ">=", ">", "<", "!=", "=="])
		logical_symbols.addAll(#["AND", "OR"])
		math_symbols.addAll(#["+", "-", "*", "/"])
		unary_symbols.addAll(#["-", "!"])
		variables_map.clear

		'''		
			//SPDX-License-Identifier: MIT
			pragma solidity ^0.8.14;
			
			import "./libs/EAI_Domain.sol";
			
			contract «ct.name» is EAI_Domain{
				
				uint32 beginDate; 
				uint32 dueDate; 	
				using EAI for EAI.Party;
				       
				EAI.Party application;
				EAI.Party process;
				mapping(address=>EAI.Party) mapParty;
				
				event failEvent(string _logMessage);
				event successEvent(string _logMessage);
			«««				/* --------------------------- END: commom code for all contracts ----------------------- */  
«««				
«««				/* =========== BEGIN: codes generated based in specific jabuti contract =================== */				      
		
			«IF ct !== null»
				
				
				«««				----------------- 1º STEP: ADD IMPORTS TO THE TERMS USED IN THE CONTRACT ---------------«««				
				«var terms = ct.getNameOfTheUsedTerms»
					«FOR t: terms»										
						using EAI for EAI.«t»
					«ENDFOR»
					
					
				«««				-------------- 2º STEP: Create the variables (from variables and terms block) -------------------------
				«FOR v : ct.variables»
					« IF v.term !== null»						
						«"\t"»EAI.«v.term.getTermType» «v.name»
					«ELSEIF v.expression !== null»						
						«"\t"»«v.expression.getVariableType(v.name)» «v.name»						
					«ENDIF»						
				«ENDFOR»
												
			«ENDIF»
			}
		'''

// ----------------------------------------------------------------------------------
	}

//======================================================================================================
// ================================ GET THE VARIABLES FROM EXPRESSION ================================	
	def String getVariableType(Expression expr, String var_name) {
		dataTypesIntoTheExpression.clear()
		symbolsIntoTheExpression.clear()
		 println()
		 print(var_name+" \t= ")
		if (expr !== null) {
			getDataTypesAndValuesFromVariables_Expression(expr)

			// verify if the expression contains some logical, comparison o Negation operator			
			for (s : symbolsIntoTheExpression) {
				if (comparison_symbols.contains(s) || logical_symbols.contains(s) || s.equals("!")) {
					// print("\t : bool ")
					variables_map.put(var_name, "bool")
					return "bool"
				}
			}

			if (dataTypesIntoTheExpression.contains("String")) {
				variables_map.put(var_name, "String")
				// print("\t : String ")								
				return "String"
			} else if (dataTypesIntoTheExpression.contains("uint32")) {
				variables_map.put(var_name, "uint32")
				// print("\t : uint32 ")					
				return "uint32"
			}
		}
	}

	def void getDataTypesAndValuesFromVariables_Expression(Expression expr) {
		
		switch expr {
			ParenthesizedExpression: { // Novo caso para parênteses
			 print("(")
				getDataTypesAndValuesFromVariables_Expression(expr.expression)
			 print(")")
			}
			BinaryOperator: {
				getDataTypesAndValuesFromVariables_Expression(expr.left)
				 print(expr.symbol)
				symbolsIntoTheExpression.add(expr.symbol)
				getDataTypesAndValuesFromVariables_Expression(expr.right)
			}
			UnaryOperator: {
				 print(expr.symbol)
				symbolsIntoTheExpression.add(expr.symbol)
				getDataTypesAndValuesFromVariables_Expression(expr.expression)
			}
			VariableValue: {
				 print(expr.value.name)				
				dataTypesIntoTheExpression.add(variables_map.get(expr.value.name))
			}
			LiteralValue: {
				if (expr instanceof StringValue) {
					var aux = expr as StringValue
					print(aux.value)
					dataTypesIntoTheExpression.add("String")

				} else if (expr instanceof NumericValue) {
					InputOutput.print((expr as NumericValue).value)
					dataTypesIntoTheExpression.add("uint32")
				}
			}
			default: {
				print("Unknown expression type: " + expr)
			}
		}
	}

// ===========================================================================================================
// ====================== GET VARIABLES BASED IN THE (VARIABLES AND TERMS BLOCK)  ============================	
	def static List<String> getNameOfTheUsedTerms(Contract ct) {
		
		val terms = newArrayList;		

		if(ct.variables !== null){
			terms.getNameOfTermsUsedInVariablesBlock(ct.variables)
		}
		if (ct.clauses !== null) {
			for (c : ct.clauses) {
				if (c.terms !== null) {
					terms.getTermsTypeFromTermBlock(c.terms)					
				}
			}
			
		}
		return terms
	}

	def static void getTermsTypeFromTermBlock(List<String> terms, ExpressionTerm exprTerm) {

		switch exprTerm {
			BinaryTermOperator: {
				getTermsTypeFromTermBlock(terms, exprTerm.left)
				println(exprTerm.symbol)
				// symbolsIntoTheExpression.add(expr.symbol)
				getTermsTypeFromTermBlock(terms, exprTerm.right)
			}
			UnaryTermOperator: {
				println("UnaryTerm")
				// symbolsIntoTheExpression.add(exprTerm.symbol)
				var unary = exprTerm as UnaryTermOperator
				getTermsTypeFromTermBlock(terms, unary.expressionTerm)
			}
			Term: {
				var term = exprTerm as Term
				var type = term.getTermType
				//println(type)
				terms.insertNewValueInListIfDoesntExist(type)				
			}
			ConditionalExpression: {
				println("ConditionalExpression")// fazer o tratamento para a conditional expression
			}
			default: {
				println("Unknown term type: " + exprTerm)
			}
		}
	}

	def static void getNameOfTermsUsedInVariablesBlock(List<String> terms, List<Variable> variables) {
		
			variables.forEach [ v |
				if (v.term !== null) {
					val termType = v.term.getTermType
					terms.insertNewValueInListIfDoesntExist(termType)
				}
			]			
	}


	def static String getTermType(Term tm) {
		
		val termType = tm.eClass().getName()
		if (termType.equalsIgnoreCase("WeekDaysInterval") || termType.equalsIgnoreCase("TimeInterval") ||
			termType.equalsIgnoreCase("Timeout") || termType.equalsIgnoreCase("SessionInterval")) {
			return termType // WeekDaysInterval | TimeInterval | Timeout
		} // ================================= MaxNumberOfOperation	================================= 
		else if (termType.equalsIgnoreCase("MaxNumberOfOperation")) {
			val maxNumberOfOperation = tm as MaxNumberOfOperation

			if (maxNumberOfOperation.timeUnit !== null) {
				return termType + "ByTime" // MaxNumberOfOperationByTime
			}
			return termType // MaxNumberOfOperation
		} // ================================= MessageContent =================================
		else if (termType.equalsIgnoreCase("MessageContent")) {

			// 'MessageContent' '(' returnType= DataType ":" (content=STRING | variable=[Variable]) (comparisonOperator=ComparisonOperator expression=Expression ('per' timeUnit=TimeUnit)?)?  ')' 
			val messageContent = tm as MessageContent

			if (messageContent.expression === null) {
				// if (messageContent.content !== null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_onlyXPath_String" // MessageContent_onlyXPath_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_onlyXPath_Number" // MessageContent_onlyXPath_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_onlyXPath_Bollean" // MessageContent_onlyXPath_Boolean
				}
			} else if (messageContent.timeUnitSpec === null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_String" // MessageContent_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number" // MessageContent_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_Boolean" // MessageContent_Boolean
				}
			} else {
				if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number_PerTime" // MessageContent_Number_PerTime
				} else {
					return "//MessageContent_Number_PerTime is used only to numeric type"
				}
			}
		}
	}



	// ================================ BUILD THE STRUCT NAME USED IN SOLID EAI LIBRARY ============================
//	def static String getTermType(Variable variable) {
//		var type = getTermType(variable.term)
//		variables_map.put(variable.name, type)
//		return type
//	}
	// buildTheNameOfTheTermAsTheSolidityTermStructureName
	
	
	// ================================ General methods ============================
	
	def static insertNewValueInListIfDoesntExist(List<String> list, String value){
		if(!list.contains(value)){
			list.add(value)
		}
//		else{
//			println(value+" já existe na lista")
//		}
	}
	
	def static boolean isNumeric(String str) {
		try {
			Integer.parseInt(str)
			return true
		} catch (NumberFormatException e) {
			try {
				Double.parseDouble(str)
				return true
			} catch (NumberFormatException e1) {
				return false
			}
		}
	}

//	def static String subTypeTer(Term tm){
//		val subTypeTermName=""
//		
//		// MessageContent
//		// SessionInterval | WeekDaysInterval | TimeInterval | Timeout | MaxNumberOfOperation | MessageContent
//		return subTypeTermName
//		
//	}
}
//				Party «ct.application.name»;
//				Party «ct.process.name»;
//				«getTerms(ct.clauses.get(0).terms)»
//				
//				
//				event «ct.clauses.get(0).name+"event"»(string _logMessage);
//				
//				constructor(address _applicationWallet, address _processWallet){
//			    	«ct.application.name» = Party("«ct.process.name» ", _applicationWallet);
//				    «ct.process.name» = Party("«ct.process.name»", _processWallet);
//				}
//				
//				function «ct.clauses.get(0).name»(uint32 _accessDateTime, string memory _xPathContent, bool _xPathResult, address _performer) public returns(bool){
//								
//					
//					bool isBreached=false;
//					
//					if(«getConditionals(ct.clauses.get(0).terms)») {
//						operationLimit.requestsPerformed+=1;
//			        	return true;	
//					}
//					
//					emit «ct.clauses.get(0).name+"event"» ("Request made outside of allowed hours or distance limit exceeded");
//					return false;
//				}
//			}
//		'''
//	}
//
//	def getTS(String date){
//		return (Timestamp.valueOf(date).getTime()/1000);
//	}
//	
//	def getTerms(Terms term){
//		'''
//			«FOR c: term.eAllContents.toIterable»
//				«IF(c instanceof Timeout)»
//					Timeout public timeout = Timeout(«c.seconds», 0);
//				«ELSEIF(c instanceof WeekDaysInterval)»
//					WeekDaysInterval public weekDaysInterval = WeekDaysInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof TimeInterval)»
//					TimeInterval public timeInterval = TimeInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof MaxNumberOfOperation)»
//					MaxNumberOfOperation public maxNumberOfOperation = MaxNumberOfOperation(«c.operationsNumber», «c.timeUnit», 0, 0);
//				«ELSEIF(c instanceof MessageContent)»
//					MessageContent public messageContent = MessageContent("«c.content»");
//				«ENDIF»
//			«ENDFOR»
//		'''
//	}
//	
//	def getConditionals(Terms terms){
//		'''	
//		«FOR c: terms.eAllContents.toIterable»
//			«IF(c instanceof Timeout)»
//				!isTimeout(_accessDateTime, timeout.endTime) &&
//			«ELSEIF(c instanceof WeekDaysInterval)»
//				isBusinessDay(_accessDateTime, businessDay) &&
//			«ELSEIF(c instanceof TimeInterval)»
//				isIntoTimeInterval(_accessDateTime, timeInterval) &&
//			«ELSEIF(c instanceof MaxNumberOfOperation)»
//				!isOperationLimitReached(_accessDateTime, operationLimit) &&
//			«ENDIF»
//		«ENDFOR»
//		'''
//}
