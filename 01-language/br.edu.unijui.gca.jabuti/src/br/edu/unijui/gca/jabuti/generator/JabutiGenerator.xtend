/*
 * generated by Xtext 2.28.0
 */
package br.edu.unijui.gca.jabuti.generator

import br.edu.unijui.gca.jabuti.jabuti.BinaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.BinaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Contract
import br.edu.unijui.gca.jabuti.jabuti.DataType
import br.edu.unijui.gca.jabuti.jabuti.Expression
import br.edu.unijui.gca.jabuti.jabuti.MaxNumberOfOperation
import br.edu.unijui.gca.jabuti.jabuti.MessageContent
import br.edu.unijui.gca.jabuti.jabuti.NumericValue
import br.edu.unijui.gca.jabuti.jabuti.StringValue
import br.edu.unijui.gca.jabuti.jabuti.Term
import br.edu.unijui.gca.jabuti.jabuti.VariableValue
import java.util.HashSet

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.edu.unijui.gca.jabuti.jabuti.LiteralValue
import br.edu.unijui.gca.jabuti.jabuti.UnaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Variable
import br.edu.unijui.gca.jabuti.jabuti.ParenthesizedExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JabutiGenerator extends AbstractGenerator {

//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//	}
	static var comparison_symbols = newArrayList
	static var logical_symbols = newArrayList
	static var math_symbols = newArrayList
	static var unary_symbols = newArrayList
	static var variables_map = newHashMap
	static var dataTypesIntoTheExpression = newArrayList
	static var symbolsIntoTheExpression = newArrayList

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (c : resource.allContents.filter(Contract).toIterable) {
			fsa.generateFile(c.name + '.sol', generateSolCode(c))
		}

	}

	def generateSolCode(Contract ct) {

		comparison_symbols.addAll(#["<=", ">=", ">", "<", "!=", "=="])
		logical_symbols.addAll(#["AND", "OR"])
		math_symbols.addAll(#["+", "-", "*", "/"])
		unary_symbols.addAll(#["-", "!"])
		variables_map.clear

		'''		
			//SPDX-License-Identifier: MIT
			pragma solidity ^0.8.14;
			
			import "./libs/EAI_Domain.sol";
			
			contract «ct.name» is EAI_Domain{
				
				uint32 beginDate; 
				uint32 dueDate; 	
				using EAI for EAI.Party;
				       
				EAI.Party application;
				EAI.Party process;
				mapping(address=>EAI.Party) mapParty;
				
				event failEvent(string _logMessage);
				event successEvent(string _logMessage);
			«««				/* --------------------------- END: commom code for all contracts ----------------------- */  
«««				
«««				/* =========== BEGIN: codes generated based in specific jabuti contract =================== */				      
		
			«IF ct !== null»
				
				«««				--------------------------------------------------------------------------------
«««				-------------------- 1º STEP: ADD IMPORTS TO THE USED TERMS --------------------
				«val terms = getNameOfTheUsedTerms(ct) »
				«FOR t: terms»										
					«"\t"»using EAI for EAI.«t»
				«ENDFOR»
					
				«««				--------------------------------------------------------------------------------
«««				------------------------ 2º STEP: Create the variables -------------------------
				«FOR v : ct.variables»
					« IF v.term !== null»						
						«"\t"»EAI.«v.getTermType» «v.name»
					«ELSEIF v.expression !== null»						
						 «"\t"»«v.expression.getVariableType(v.name)» «v.name»						
					«ENDIF»						
				«ENDFOR»				
				}
			«ENDIF»
			
		'''

// ----------------------------------------------------------------------------------
	}
//======================================================================================================
// ================================ Create the variables ( EXPRESSION ) ================================	
	def String getVariableType(Expression expr, String var_name) {
		dataTypesIntoTheExpression.clear()
		symbolsIntoTheExpression.clear()
		//println()
		//print(var_name+" \t= ")
		if (expr !== null) {
			printExpressionInOneLine(expr)

			// verify if the expression contains some logical, comparison o Negation operator			
			for (s : symbolsIntoTheExpression) {
				if (comparison_symbols.contains(s) || logical_symbols.contains(s) || s.equals("!")) {
					//print("\t : bool ")
					variables_map.put(var_name, "bool")
					return "bool"
				}
			}

			if (dataTypesIntoTheExpression.contains("String")) {
				variables_map.put(var_name, "String")
				//print("\t : String ")								
				return "String"
			} else if (dataTypesIntoTheExpression.contains("uint32")) {
				variables_map.put(var_name, "uint32")			
				//print("\t : uint32 ")					
				return "uint32"
			} 
		}
	}

	def void printExpressionInOneLine(Expression expr) {
		switch expr {
			ParenthesizedExpression: { // Novo caso para parênteses
				//print("(")
				printExpressionInOneLine(expr.expression)
				//print(")")
			}
			BinaryOperator: {
				printExpressionInOneLine(expr.left)
				//print(expr.symbol)
				symbolsIntoTheExpression.add(expr.symbol)
				printExpressionInOneLine(expr.right)
			}
			UnaryOperator: {
				//print(expr.symbol)
				symbolsIntoTheExpression.add(expr.symbol)
				printExpressionInOneLine(expr.expression)
			}
			VariableValue: {
				//print(expr.value.name)				
				dataTypesIntoTheExpression.add(variables_map.get(expr.value.name))
			}
			LiteralValue: {
				if (expr instanceof StringValue) {
					var aux = expr as StringValue
					//print(aux.value)
					dataTypesIntoTheExpression.add("String")

				} else if (expr instanceof NumericValue) {
					InputOutput.print((expr as NumericValue).value)
					dataTypesIntoTheExpression.add("uint32")
				}
			}
			default: {
				print("Unknown expression type: " + expr)
			}
		}
	}
	
// ===========================================================================================================
// ===================================== Identify all Terms used in a contract  ==============================	
	def static HashSet<String> getNameOfTheUsedTerms(Contract ct) {
		val terms = newHashSet;
		terms.addAll(ct.getNameOfTermsUsedInVariablesBlock)
		terms.addAll(ct.getNameOfTermsUsedInTermsBlock)
		return terms
	}

// ================================ GET THE NAME OF THE TERMS USED IN VARIABLES BLOCK ============================
	def static HashSet<String> getNameOfTermsUsedInVariablesBlock(Contract ct) {
		val result = newHashSet
		if (ct.variables !== null) {
			ct.variables.forEach [ variable |
				if (variable.term !== null) {
					val termType = variable.getTermType
					result.add(termType)
				}
			]
		}
		return result
	}

// ================================ GET THE NAME OF THE TERMS USED IN CLAUSES BLOCK ============================
	def static HashSet<String> getNameOfTermsUsedInTermsBlock(Contract ct) {
		val termTypes = newHashSet
		for (cl : ct.clauses) {
			if (cl.terms !== null) {
				if (cl.terms.expressionTerm !== null) {
					if (cl.terms.expressionTerm.get(0) instanceof BinaryTermOperator) {
						val binaryTermOperator = cl.terms.expressionTerm.get(0) as BinaryTermOperator
						extractTermTypesFromBinaryTermOperator(binaryTermOperator, termTypes)
					} else {
						// println("não é binaryOperator")
					}
				}
			}
		}
		return termTypes
	}

	def static HashSet<String> extractTermTypesFromBinaryTermOperator(BinaryTermOperator binary, HashSet<String> term) {

		if (binary.left !== null) {
			if (binary.left instanceof BinaryTermOperator) {
				val b_aux = binary.left as BinaryTermOperator
				extractTermTypesFromBinaryTermOperator(b_aux, term)
			} else {
				term.add(getTermType(binary.left as Term))
			}
		}
		term.add(getTermType(binary.right as Term))
		return term

	}

// ==============================================================================================
//	if (exp instanceof MaxNumberOfOperation) {
//				println("é instancia de MaxNumberOfOperation")
//				termTypes.add("MaxNumberOfOperation-of-clause")
//			}
//	def static ArrayList<String> geClauseTerms(Contract ct) {
//		val result = newArrayList
//		if (ct.clauses !== null) {
//			ct.clauses.forEach [ clause |
//				if (clause.terms !== null) {
//						val terms = clause.terms;						
//						if(terms.expressionTerm !== null){
//							terms.expressionTerm.forEach[term |
//								val termType = term.getTermType
//								result.add(termType)
//							] 
//						}
//				}
//			]
//		}
//		return result
//	}

	
	// ================================ BUILD THE STRUCT NAME USED IN SOLID EAI LIBRARY ============================
	def static String getTermType(Variable variable) {
		var type = getTermType(variable.term)
		variables_map.put(variable.name, type)
		return type
	}

	// buildTheNameOfTheTermAsTheSolidityTermStructureName
	def static String getTermType(Term tm) {
		val termType = tm.eClass().getName()
		if (termType.equalsIgnoreCase("WeekDaysInterval") || termType.equalsIgnoreCase("TimeInterval") ||
			termType.equalsIgnoreCase("Timeout") || termType.equalsIgnoreCase("SessionInterval")) {
			return termType // WeekDaysInterval | TimeInterval | Timeout
		} // ================================= MaxNumberOfOperation	================================= 
		else if (termType.equalsIgnoreCase("MaxNumberOfOperation")) {
			val maxNumberOfOperation = tm as MaxNumberOfOperation

			if (maxNumberOfOperation.timeUnit !== null) {
				return termType + "ByTime" // MaxNumberOfOperationByTime
			}
			return termType // MaxNumberOfOperation
		} // ================================= MessageContent =================================
		else if (termType.equalsIgnoreCase("MessageContent")) {

			// 'MessageContent' '(' returnType= DataType ":" (content=STRING | variable=[Variable]) (comparisonOperator=ComparisonOperator expression=Expression ('per' timeUnit=TimeUnit)?)?  ')' 
			val messageContent = tm as MessageContent

			if (messageContent.expression === null) {
				// if (messageContent.content !== null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_onlyXPath_String" // MessageContent_onlyXPath_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_onlyXPath_Number" // MessageContent_onlyXPath_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_onlyXPath_Bollean" // MessageContent_onlyXPath_Boolean
				}
			} else if (messageContent.timeUnitSpec === null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_String" // MessageContent_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number" // MessageContent_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_Boolean" // MessageContent_Boolean
				}
			} else {
				if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number_PerTime" // MessageContent_Number_PerTime
				} else {
					return "//MessageContent_Number_PerTime is used only to numeric type"
				}
			}
		}
	}

	def static boolean isNumeric(String str) {
		try {
			Integer.parseInt(str)
			return true
		} catch (NumberFormatException e) {
			try {
				Double.parseDouble(str)
				return true
			} catch (NumberFormatException e1) {
				return false
			}
		}
	}

//	def static String subTypeTer(Term tm){
//		val subTypeTermName=""
//		
//		// MessageContent
//		// SessionInterval | WeekDaysInterval | TimeInterval | Timeout | MaxNumberOfOperation | MessageContent
//		return subTypeTermName
//		
//	}
}
//				Party «ct.application.name»;
//				Party «ct.process.name»;
//				«getTerms(ct.clauses.get(0).terms)»
//				
//				
//				event «ct.clauses.get(0).name+"event"»(string _logMessage);
//				
//				constructor(address _applicationWallet, address _processWallet){
//			    	«ct.application.name» = Party("«ct.process.name» ", _applicationWallet);
//				    «ct.process.name» = Party("«ct.process.name»", _processWallet);
//				}
//				
//				function «ct.clauses.get(0).name»(uint32 _accessDateTime, string memory _xPathContent, bool _xPathResult, address _performer) public returns(bool){
//								
//					
//					bool isBreached=false;
//					
//					if(«getConditionals(ct.clauses.get(0).terms)») {
//						operationLimit.requestsPerformed+=1;
//			        	return true;	
//					}
//					
//					emit «ct.clauses.get(0).name+"event"» ("Request made outside of allowed hours or distance limit exceeded");
//					return false;
//				}
//			}
//		'''
//	}
//
//	def getTS(String date){
//		return (Timestamp.valueOf(date).getTime()/1000);
//	}
//	
//	def getTerms(Terms term){
//		'''
//			«FOR c: term.eAllContents.toIterable»
//				«IF(c instanceof Timeout)»
//					Timeout public timeout = Timeout(«c.seconds», 0);
//				«ELSEIF(c instanceof WeekDaysInterval)»
//					WeekDaysInterval public weekDaysInterval = WeekDaysInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof TimeInterval)»
//					TimeInterval public timeInterval = TimeInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof MaxNumberOfOperation)»
//					MaxNumberOfOperation public maxNumberOfOperation = MaxNumberOfOperation(«c.operationsNumber», «c.timeUnit», 0, 0);
//				«ELSEIF(c instanceof MessageContent)»
//					MessageContent public messageContent = MessageContent("«c.content»");
//				«ENDIF»
//			«ENDFOR»
//		'''
//	}
//	
//	def getConditionals(Terms terms){
//		'''	
//		«FOR c: terms.eAllContents.toIterable»
//			«IF(c instanceof Timeout)»
//				!isTimeout(_accessDateTime, timeout.endTime) &&
//			«ELSEIF(c instanceof WeekDaysInterval)»
//				isBusinessDay(_accessDateTime, businessDay) &&
//			«ELSEIF(c instanceof TimeInterval)»
//				isIntoTimeInterval(_accessDateTime, timeInterval) &&
//			«ELSEIF(c instanceof MaxNumberOfOperation)»
//				!isOperationLimitReached(_accessDateTime, operationLimit) &&
//			«ENDIF»
//		«ENDFOR»
//		'''
//}
