/*
 * generated by Xtext 2.28.0
 */
package br.edu.unijui.gca.jabuti.generator

import br.edu.unijui.gca.jabuti.jabuti.BinaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.BinaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Contract
import br.edu.unijui.gca.jabuti.jabuti.DataType
import br.edu.unijui.gca.jabuti.jabuti.Expression
import br.edu.unijui.gca.jabuti.jabuti.MaxNumberOfOperation
import br.edu.unijui.gca.jabuti.jabuti.MessageContent
import br.edu.unijui.gca.jabuti.jabuti.NumericValue
import br.edu.unijui.gca.jabuti.jabuti.StringValue
import br.edu.unijui.gca.jabuti.jabuti.Term
import br.edu.unijui.gca.jabuti.jabuti.VariableValue
import java.util.HashSet

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.edu.unijui.gca.jabuti.jabuti.LiteralValue
import java.util.ArrayList
import br.edu.unijui.gca.jabuti.jabuti.UnaryOperator
import br.edu.unijui.gca.jabuti.jabuti.Variable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JabutiGenerator extends AbstractGenerator {

//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//	}
	static var comparison_symbols = newArrayList
	static var logical_symbols = newArrayList
	static var math_symbols = newArrayList
	static var unary_symbols = newArrayList
	static var variables_map = newHashMap

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (c : resource.allContents.filter(Contract).toIterable) {
			fsa.generateFile(c.name + '.sol', generateSolCode(c))
		}

	}

	def generateSolCode(Contract ct) {

		comparison_symbols.addAll(#["<=", ">=", ">", "<", "!=", "=="])
		logical_symbols.addAll(#["AND", "OR"])
		math_symbols.addAll(#["+", "-", "*", "/"])
		unary_symbols.addAll(#["-", "!"])
		variables_map.clear
		
		'''		
			//SPDX-License-Identifier: MIT
			pragma solidity ^0.8.14;
			
			import "./libs/EAI_Domain.sol";
			
			contract «ct.name» is EAI_Domain{
				
				uint32 beginDate; 
				uint32 dueDate; 	
				using EAI for EAI.Party;
				       
				EAI.Party application;
				EAI.Party process;
				mapping(address=>EAI.Party) mapParty;
				
				event failEvent(string _logMessage);
				event successEvent(string _logMessage);
			«««				/* --------------------------- END: commom code for all contracts ----------------------- */  
«««				
«««				/* =========== BEGIN: codes generated based in specific jabuti contract =================== */				      
			«IF ct !== null»
			
			«««				--------------------------------------------------------------------------------
«««				-------------------- 1º STEP: ADD IMPORTS TO THE USED TERMS --------------------
				«val terms = getNameOfTheUsedTerms(ct) »
				«FOR t: terms»										
					«"\t"»using EAI for EAI.«t»
				«ENDFOR»
				
			«««				--------------------------------------------------------------------------------
«««				------------------------ 2º STEP: Create the variables -------------------------
				«FOR v : ct.variables»
					« IF v.term !== null»						
						EAI.«v.getTermType» «v.name»
					«ELSEIF v.expression !== null»						
						«v.getReturnedTypeByExpression» «v.name»						
					«ENDIF»						
				«ENDFOR»				
				}
			«ENDIF»
			
		'''
		
		
// ----------------------------------------------------------------------------------
	}

// ==================================== Create the variables =======================================	
//	def static HashSet<String> getVariablesName(Contract ct){
//		getTermType(Term tm)
//	}
	def static void printVariablesMap() {
		println("")
		variables_map.forEach [ p1, p2 |
			println(p2 + ", " + p1)
		]
	}

	def static String getReturnedTypeByExpression(Variable variable) {
		var type = "unknown"
		var exp = variable.expression
		if (exp instanceof BinaryOperator) {
			println("é binary")
			type = getTypeOfExpression(exp as BinaryOperator, newHashSet)
		} else if (exp instanceof UnaryOperator) {
			println("é unary")
			type = getTheTypeOfUnaryOperator(exp as UnaryOperator)
		} else if (exp instanceof LiteralValue) {
			println("é unary")
			type = getTypeOfLiteralValue(exp as LiteralValue)
		}
		variables_map.put(variable.name, type)
		return type
	}

	def static String getTypeOfExpression(BinaryOperator bop, HashSet<String> operators) {
		if (bop.left !== null) {
			if (bop.left instanceof BinaryOperator) {
//				val bop_aux = bop.left as BinaryOperator
				operators.add(bop.symbol)
				if (bop.right instanceof StringValue) {
					return "String"
				} else if (bop.right instanceof VariableValue) {
					return "Variable type" // verificar se é string ou numeric value	
				}
				getTypeOfExpression(bop.left as BinaryOperator, operators)
			}
			else if (bop.left instanceof UnaryOperator){
				
				var unary_aux = bop.left as UnaryOperator 				
				if(unary_aux.symbol.equals("-")){	
					println("left é unary negativo")				
					if(bop.right instanceof LiteralValue){
						if(unary_aux.expression instanceof LiteralValue){
							val typeExp = getTypeOfLiteralValue(unary_aux.expression as LiteralValue)
							val rightVal =  getTypeOfLiteralValue(bop.right as LiteralValue)
							
							if(typeExp.equals("String") || rightVal.equals("String")){
								return "String"
							}else if(typeExp.equals("Variable")){
								 var var_exp = unary_aux.expression as Variable
								 if (variables_map.get(var_exp.name).equals("String")){
									return "String" 	
								 }								
							}else if(rightVal.equals("Variable")){
								var var_right = bop.right as Variable
								if ( variables_map.get(var_right.name).equals("String")){
									return "String" 	
								 }					
							}else{
								return "uint32"
							}
						}else if (unary_aux.expression instanceof BinaryOperator){											
							return getTypeOfExpression(unary_aux.expression as BinaryOperator, operators)						
						}					
					}
					else if (bop.right instanceof BinaryOperator){											
						return getTypeOfExpression(bop.right as BinaryOperator, operators)						
					}					
					return "unknown 1"	
				}
				
//				else if(unary_aux.symbol.equals("!")){					
//					return "unary bool"				
//				}
//				return "unknown 2"			
			}
			 else {
				operators.add(bop.symbol)
				for (String symbol : operators) {
					if (comparison_symbols.contains(symbol) || logical_symbols.contains(symbol)) {
						return "bool"
					}
				}

				if (bop.left instanceof LiteralValue) {
					val left_aux = getTypeOfLiteralValue(bop.left as LiteralValue)
					val right_aux = getTypeOfLiteralValue(bop.right as LiteralValue)					
					if (left_aux.equals("String") || right_aux.equals("String")) {
						return "String"
					} else if (left_aux.equals("Variable") || right_aux.equals("Variable")) {
						return "Variable"
					} else {
						return "uint32"
					}
				}
			}
		}
	}

	def static String getTheTypeOfUnaryOperator(UnaryOperator unary) {
		var type = "unknown"
		if (unary.symbol.equals("!")) {
			type = "Unary_only bool"
		} else if (unary.symbol.equals("-")) {
			type = "Unary_only uint32 "
		}
		return type
	}

	def static String getTypeOfLiteralValue(LiteralValue lv) {
		if (lv instanceof NumericValue) {
			return "uint32"
		} else if (lv instanceof StringValue) {
			return "String"
		} else if (lv instanceof VariableValue) {
			return "Variable"
		}
	}

// =============================== Identify all Terms used in a contract  ==========================	
	def static HashSet<String> getNameOfTheUsedTerms(Contract ct) {
		val terms = newHashSet;

		terms.addAll(ct.getNameOfTermsUsedInVariablesBlock)
		terms.addAll(ct.getNameOfTermsUsedInTermsBlock)

		return terms
	}

// ================================ GET THE NAME OF THE TERMS USED IN VARIABLES BLOCK ============================
	def static HashSet<String> getNameOfTermsUsedInVariablesBlock(Contract ct) {
		val result = newHashSet
		if (ct.variables !== null) {
			ct.variables.forEach [ variable |
				if (variable.term !== null) {
					val termType = variable.getTermType
					result.add(termType)
				}
			]
		}
		return result
	}

// ================================ GET THE NAME OF THE TERMS USED IN CLAUSES BLOCK ============================
	def static HashSet<String> getNameOfTermsUsedInTermsBlock(Contract ct) {
		val termTypes = newHashSet
		for (cl : ct.clauses) {
			if (cl.terms !== null) {
				if (cl.terms.expressionTerm !== null) {
					if (cl.terms.expressionTerm.get(0) instanceof BinaryTermOperator) {
						val binaryTermOperator = cl.terms.expressionTerm.get(0) as BinaryTermOperator
						extractTermTypesFromBinaryTermOperator(binaryTermOperator, termTypes)
					} else {
						// println("não é binaryOperator")
					}
				}
			}
		}
		return termTypes
	}

	def static HashSet<String> extractTermTypesFromBinaryTermOperator(BinaryTermOperator binary, HashSet<String> term) {

		if (binary.left !== null) {
			if (binary.left instanceof BinaryTermOperator) {
				val b_aux = binary.left as BinaryTermOperator
				extractTermTypesFromBinaryTermOperator(b_aux, term)
			} else {
				term.add(getTermType(binary.left as Term))
			}
		}
		term.add(getTermType(binary.right as Term))
		return term

	}

// ==============================================================================================
//	if (exp instanceof MaxNumberOfOperation) {
//				println("é instancia de MaxNumberOfOperation")
//				termTypes.add("MaxNumberOfOperation-of-clause")
//			}
//	def static ArrayList<String> geClauseTerms(Contract ct) {
//		val result = newArrayList
//		if (ct.clauses !== null) {
//			ct.clauses.forEach [ clause |
//				if (clause.terms !== null) {
//						val terms = clause.terms;						
//						if(terms.expressionTerm !== null){
//							terms.expressionTerm.forEach[term |
//								val termType = term.getTermType
//								result.add(termType)
//							] 
//						}
//				}
//			]
//		}
//		return result
//	}
	// ================================ BUILD THE STRUCT NAME USED IN SOLID EAI LIBRARY ============================
	def static String getTermType(Variable variable) {
		var type = getTermType(variable.term)
		variables_map.put(variable.name, type)
		return type
	}

	def static String getTermType(Term tm) {
		val termType = tm.eClass().getName()
		if (termType.equalsIgnoreCase("WeekDaysInterval") || termType.equalsIgnoreCase("TimeInterval") ||
			termType.equalsIgnoreCase("Timeout") || termType.equalsIgnoreCase("SessionInterval")) {
			return termType // WeekDaysInterval | TimeInterval | Timeout
		} // ================================= MaxNumberOfOperation	================================= 
		else if (termType.equalsIgnoreCase("MaxNumberOfOperation")) {
			val maxNumberOfOperation = tm as MaxNumberOfOperation

			if (maxNumberOfOperation.timeUnit !== null) {
				return termType + "ByTime" // MaxNumberOfOperationByTime
			}
			return termType // MaxNumberOfOperation
		} // ================================= MessageContent =================================
		else if (termType.equalsIgnoreCase("MessageContent")) {

			// 'MessageContent' '(' returnType= DataType ":" (content=STRING | variable=[Variable]) (comparisonOperator=ComparisonOperator expression=Expression ('per' timeUnit=TimeUnit)?)?  ')' 
			val messageContent = tm as MessageContent

			if (messageContent.expression === null) {
				// if (messageContent.content !== null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_onlyXPath_String" // MessageContent_onlyXPath_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_onlyXPath_Number" // MessageContent_onlyXPath_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_onlyXPath_Bollean" // MessageContent_onlyXPath_Boolean
				}
			} else if (messageContent.timeUnitSpec === null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_String" // MessageContent_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number" // MessageContent_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_Boolean" // MessageContent_Boolean
				}
			} else {
				if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number_PerTime" // MessageContent_Number_PerTime
				} else {
					return "//MessageContent_Number_PerTime is used only to numeric type"
				}
			}
		}
	}

	def static boolean isNumeric(String str) {
		try {
			Integer.parseInt(str)
			return true
		} catch (NumberFormatException e) {
			try {
				Double.parseDouble(str)
				return true
			} catch (NumberFormatException e1) {
				return false
			}
		}
	}

//	def static String subTypeTer(Term tm){
//		val subTypeTermName=""
//		
//		// MessageContent
//		// SessionInterval | WeekDaysInterval | TimeInterval | Timeout | MaxNumberOfOperation | MessageContent
//		return subTypeTermName
//		
//	}
}
//				Party «ct.application.name»;
//				Party «ct.process.name»;
//				«getTerms(ct.clauses.get(0).terms)»
//				
//				
//				event «ct.clauses.get(0).name+"event"»(string _logMessage);
//				
//				constructor(address _applicationWallet, address _processWallet){
//			    	«ct.application.name» = Party("«ct.process.name» ", _applicationWallet);
//				    «ct.process.name» = Party("«ct.process.name»", _processWallet);
//				}
//				
//				function «ct.clauses.get(0).name»(uint32 _accessDateTime, string memory _xPathContent, bool _xPathResult, address _performer) public returns(bool){
//								
//					
//					bool isBreached=false;
//					
//					if(«getConditionals(ct.clauses.get(0).terms)») {
//						operationLimit.requestsPerformed+=1;
//			        	return true;	
//					}
//					
//					emit «ct.clauses.get(0).name+"event"» ("Request made outside of allowed hours or distance limit exceeded");
//					return false;
//				}
//			}
//		'''
//	}
//
//	def getTS(String date){
//		return (Timestamp.valueOf(date).getTime()/1000);
//	}
//	
//	def getTerms(Terms term){
//		'''
//			«FOR c: term.eAllContents.toIterable»
//				«IF(c instanceof Timeout)»
//					Timeout public timeout = Timeout(«c.seconds», 0);
//				«ELSEIF(c instanceof WeekDaysInterval)»
//					WeekDaysInterval public weekDaysInterval = WeekDaysInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof TimeInterval)»
//					TimeInterval public timeInterval = TimeInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof MaxNumberOfOperation)»
//					MaxNumberOfOperation public maxNumberOfOperation = MaxNumberOfOperation(«c.operationsNumber», «c.timeUnit», 0, 0);
//				«ELSEIF(c instanceof MessageContent)»
//					MessageContent public messageContent = MessageContent("«c.content»");
//				«ENDIF»
//			«ENDFOR»
//		'''
//	}
//	
//	def getConditionals(Terms terms){
//		'''	
//		«FOR c: terms.eAllContents.toIterable»
//			«IF(c instanceof Timeout)»
//				!isTimeout(_accessDateTime, timeout.endTime) &&
//			«ELSEIF(c instanceof WeekDaysInterval)»
//				isBusinessDay(_accessDateTime, businessDay) &&
//			«ELSEIF(c instanceof TimeInterval)»
//				isIntoTimeInterval(_accessDateTime, timeInterval) &&
//			«ELSEIF(c instanceof MaxNumberOfOperation)»
//				!isOperationLimitReached(_accessDateTime, operationLimit) &&
//			«ENDIF»
//		«ENDFOR»
//		'''
//}
