/*
 * generated by Xtext 2.28.0
 */
package br.edu.unijui.gca.jabuti.generator

import br.edu.unijui.gca.jabuti.generator.entities.StructVar
import br.edu.unijui.gca.jabuti.generator.entities.VarExpr
import br.edu.unijui.gca.jabuti.jabuti.BinaryOperator
import br.edu.unijui.gca.jabuti.jabuti.BinaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.ConditionalExpression
import br.edu.unijui.gca.jabuti.jabuti.Contract
import br.edu.unijui.gca.jabuti.jabuti.DataType
import br.edu.unijui.gca.jabuti.jabuti.Expression
import br.edu.unijui.gca.jabuti.jabuti.ExpressionTerm
import br.edu.unijui.gca.jabuti.jabuti.LiteralValue
import br.edu.unijui.gca.jabuti.jabuti.MaxNumberOfOperation
import br.edu.unijui.gca.jabuti.jabuti.MessageContent
import br.edu.unijui.gca.jabuti.jabuti.NumericValue
import br.edu.unijui.gca.jabuti.jabuti.ParenthesizedExpression
import br.edu.unijui.gca.jabuti.jabuti.StringValue
import br.edu.unijui.gca.jabuti.jabuti.Term
import br.edu.unijui.gca.jabuti.jabuti.UnaryOperator
import br.edu.unijui.gca.jabuti.jabuti.UnaryTermOperator
import br.edu.unijui.gca.jabuti.jabuti.Variable
import br.edu.unijui.gca.jabuti.jabuti.VariableValue
import java.util.ArrayList
import java.util.LinkedHashMap
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.edu.unijui.gca.jabuti.generator.entities.VarTerm
import br.edu.unijui.gca.jabuti.generator.entities.terms.MessageContent_onlyXPath_String
import br.edu.unijui.gca.jabuti.generator.entities.terms.Timeout

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JabutiGenerator extends AbstractGenerator {

//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//	}
	static var comparison_symbols = newArrayList
	static var logical_symbols = newArrayList
	static var math_symbols = newArrayList
	static var unary_symbols = newArrayList

	LinkedHashMap<String, StructVar> variablesMap
	ArrayList<String> exprContent_temp
	String exprVarName_temp

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (c : resource.allContents.filter(Contract).toIterable) {
			fsa.generateFile(c.name + '.sol', generateSolCode(c))
		}

	}

	def generateSolCode(Contract ct) {

		comparison_symbols.addAll(#["<=", ">=", ">", "<", "!=", "=="])
		logical_symbols.addAll(#["AND", "OR"])
		math_symbols.addAll(#["+", "-", "*", "/"])
		unary_symbols.addAll(#["-", "!"])
		// variables_map.clear
		exprContent_temp = new ArrayList<String>
		variablesMap = new LinkedHashMap<String, StructVar>

		'''		
			//SPDX-License-Identifier: MIT
			pragma solidity ^0.8.14;
			
			import "./libs/EAI_Domain.sol";
			
			contract «ct.name» is EAI_Domain{
				
				uint32 beginDate; 
				uint32 dueDate; 	
				using EAI for EAI.Party;
				       
				EAI.Party application;
				EAI.Party process;
				mapping(address=>EAI.Party) mapParty;
				
				event failEvent(string _logMessage);
				event successEvent(string _logMessage);
			«««				/* --------------------------- END: commom code for all contracts ----------------------- */  
«««				
«««				/* =========== BEGIN: codes generated based in specific jabuti contract =================== */				      
		
			«IF ct !== null»
								
				«««				----------------- 1º STEP: ADD IMPORTS TO THE TERMS USED IN THE CONTRACT ---------------«««				
				«var terms = ct.getNameOfTheUsedTerms»
					«FOR t: terms»										
						using EAI for EAI.«t»
					«ENDFOR»
					
					
				«««				-------------- 2º STEP: Create the variables (from variables and terms block) -------------------------
				«FOR v : ct.variables»
					« IF v.term !== null»						
						«"\t"»EAI.«v.term.getTermType» «v.name»
					«ELSEIF v.expression !== null»						
						«"\t"»«v.expression.getVariableType(v.name)» «v.name»						
					«ENDIF»						
				«ENDFOR»
				
			«ENDIF»
						««« «printVariablesMapContent()» »»
			
			/* -------------- END: codes generated based in specific jabuti contract ------------- */
			
			
			/* ========================== BEGIN: code for all contracts ====================== */
			
			    /* the process sign the contract by default, the function signContract 
			    is used to get the applicationParty signature*/      
			    function signContract() public onlyApplication() returns(bool) {
			        require(application.aware == false, "The contract is already signed");        
			        application.aware = true;  
			        updateMapParty(msg.sender, application);
					return true;
			    }
			
			    function updateMapParty(address _walletAddress, EAI.Party storage _party)internal returns(bool){       
			        mapParty[_walletAddress] = _party;
					return true;
			    }
			    
			    /* It only possible to change the name and the address of the party. 
			    After change the  party, the new party need to sign the contract */
			    function changeApplicationParty(string memory _name, address _walletAddress) public returns(bool) {       
			        require(process.walletAddress == msg.sender, "Only the process can execute this operation");
			        delete mapParty[application.walletAddress];
			        application = EAI.createParty(_name, _walletAddress, false);          
			        updateMapParty(_walletAddress, application);
			        return true;       
			    }
			    
			    function getProcessAddress() public view onlyInvolvedParties returns(address){
			        return process.walletAddress;
			    }
			    
			    function getApplicationAddress() public view onlyInvolvedParties returns(address){
			        return application.walletAddress;
			    }
			
			    function getParty(address _walletAddress) public view onlyInvolvedParties returns(EAI.Party memory){
			        return mapParty[_walletAddress];
			    }
			    
			/* ==================================== MODIFIERS ==================================== */
			        modifier onlyApplication(){        
			            require(activated, "This contract is deactivated");            
			            require(application.walletAddress == msg.sender, "Only the application can execute this operation");
			            _;        
			    }
			
			    modifier onlyProcess(){
			        require(activated, "This contract is deactivated");
			        require(process.walletAddress == msg.sender, "Only the process can execute this operation");
			        _;
			    }
			
			    modifier onlyInvolvedParties(){
			        require(activated, "This contract is deactivated");
			        require(
			            (application.walletAddress == msg.sender || process.walletAddress == msg.sender ) ,
			            "Only the process or the application can execute this operation");
			        _;
			    }
			
			}
			/* --------------------------- END: code for all contracts ----------------------- */			
		'''

// ----------------------------------------------------------------------------------
	}

	// temp listar conteudo do variablesMap
	def void printVariablesMapContent() {
		println("\n\n")
		println("----")
		variablesMap.forEach [ p1, p2 |
			if (p2 instanceof VarExpr) {
				print(p2.type + " " + p2.name + " = ")
				p2.content.forEach[p|print(" " + p.toString)]
			}
			if (p2 instanceof VarTerm) {
				(p2 as VarTerm).printTermStruct
			}
			println("")
		]
		println("----")
	}

	def void printTermStruct(VarTerm vt) {	
		switch vt.term {
			MessageContent_onlyXPath_String: {
				println("MessageContent_onlyXPath_String")
			}
			Timeout: {
				println("Timeout")
			}
			default: {
				println("unknown")
			}
		}

	}

//	def void printVariablesMapContent(){
//		 // Iterando e listando itens na ordem de inserção
//        for (variablesMap.Entry<String, VarExpr> entry : map.entrySet()) {
//            System.out.println(entry.getKey() + ": " + entry.getValue());
//        }
//	}
//======================================================================================================
// ================================ GET THE VARIABLES FROM EXPRESSION ================================	
	def String getVariableType(Expression expr, String var_name) {
		// dataTypesIntoTheExpression.clear()
		// symbolsIntoTheExpression.clear()
		exprContent_temp.clear() // empty expression	
		if (expr !== null) {
			getDataTypesAndValuesFromVariables_Expression(expr)
			variablesMap.put(var_name, new VarExpr(var_name, "unknown", exprContent_temp))

			// verify if the expression contains some logical, comparison o Negation operator			
			for (s : exprContent_temp) {
				if (comparison_symbols.contains(s) || logical_symbols.contains(s) || s.equals("!")) {
					variablesMap.get(var_name).type = "bool"
					return "bool"
				}
			}

			for (item : exprContent_temp) {
				if (item.contains("\"")) {
					variablesMap.get(var_name).type = "String"
					return "String"
				}
			}

			// if it is not a bool or string type then it is an uint32 type 
			variablesMap.get(var_name).type = "uint32"
			return "uint32"
		}
	}

	def void getDataTypesAndValuesFromVariables_Expression(Expression expr) {

		switch expr {
			ParenthesizedExpression: { // Novo caso para parênteses
//				print("(")
				exprContent_temp.add("(")
				getDataTypesAndValuesFromVariables_Expression(expr.expression)
//				print(")")
				exprContent_temp.add(")")
			}
			BinaryOperator: {
				getDataTypesAndValuesFromVariables_Expression(expr.left)
//				print(expr.symbol)
				exprContent_temp.add(expr.symbol)
				// symbolsIntoTheExpression.add(expr.symbol)
				getDataTypesAndValuesFromVariables_Expression(expr.right)
			}
			UnaryOperator: {
//				print(expr.symbol)
				exprContent_temp.add(expr.symbol)
				// symbolsIntoTheExpression.add(expr.symbol)
				getDataTypesAndValuesFromVariables_Expression(expr.expression)
			}
			VariableValue: {
//				print(expr.value.name)
				exprContent_temp.add(expr.value.name)
			// variablesMap.get(exprVarName_temp).type = variablesMap.get(expr.value.name).type
			// dataTypesIntoTheExpression.add(variables_map.get(expr.value.name))
			}
			LiteralValue: {
				if (expr instanceof StringValue) {
					var aux = expr as StringValue
//					print(aux.value)
					exprContent_temp.add("\"" + aux.value + "\"")
				// variablesMap.get(exprVarName_temp).type = "string"
				// dataTypesIntoTheExpression.add("String")
				} else if (expr instanceof NumericValue) {
					var aux = expr as NumericValue
//					print(aux.value)
					exprContent_temp.add(aux.value.toString)
				// variablesMap.get(exprVarName_temp).type = "uint32"
				// dataTypesIntoTheExpression.add("uint32")
				}
			}
			default: {
				exprContent_temp.add("unknown")
//				print("Unknown expression type: " + expr)
			}
		}
	}

// ===========================================================================================================
// ====================== GET VARIABLES BASED IN THE (VARIABLES AND TERMS BLOCK)  ============================	
	def List<String> getNameOfTheUsedTerms(Contract ct) {

		val terms = newArrayList;

		if (ct.variables !== null) {
			terms.getNameOfTermsUsedInVariablesBlock(ct.variables)
		}
		if (ct.clauses !== null) {
			for (c : ct.clauses) {
				if (c.terms !== null) {
					terms.getTermsTypeFromTermBlock(c.terms)
				}
			}

		}
		return terms
	}

	def static void getTermsTypeFromTermBlock(List<String> terms, ExpressionTerm exprTerm) {

		switch exprTerm {
			BinaryTermOperator: {
				getTermsTypeFromTermBlock(terms, exprTerm.left)
				println(exprTerm.symbol)
				// symbolsIntoTheExpression.add(expr.symbol)
				getTermsTypeFromTermBlock(terms, exprTerm.right)
			}
			UnaryTermOperator: {
				println("UnaryTerm")
				// symbolsIntoTheExpression.add(exprTerm.symbol)
				var unary = exprTerm as UnaryTermOperator
				getTermsTypeFromTermBlock(terms, unary.expressionTerm)
			}
			Term: {
				var term = exprTerm as Term
				var type = term.getTermType
				// println(type)
				terms.insertNewValueInListIfDoesntExist(type)
			}
			ConditionalExpression: {
				println("ConditionalExpression") // fazer o tratamento para a conditional expression
			}
			default: {
				println("Unknown term type: " + exprTerm)
			}
		}
	}

	def void getNameOfTermsUsedInVariablesBlock(List<String> terms, List<Variable> variables) {

		variables.forEach [ v |
			if (v.term !== null) {

				val termType = v.term.getTermType
				terms.insertNewValueInListIfDoesntExist(termType)				
								  
				if (termType.equals("MessageContent_onlyXPath_String")) {
					variablesMap.put(v.name, new VarTerm(v.name, termType, new MessageContent_onlyXPath_String("")))
				} else if (termType.equals("Timeout")) {
					variablesMap.put(v.name, new VarTerm(v.name, termType, new Timeout(11)))
				}
			}
		]
	}
	
//	def void createTheTermStruct(String name, String type, Term){
//		
//	}

	def static String getTermType(Term tm) {

		val termType = tm.eClass().getName()
		if (termType.equalsIgnoreCase("WeekDaysInterval") || termType.equalsIgnoreCase("TimeInterval") ||
			termType.equalsIgnoreCase("Timeout") || termType.equalsIgnoreCase("SessionInterval")) {
			return termType // WeekDaysInterval | TimeInterval | Timeout
		} // ================================= MaxNumberOfOperation	================================= 
		else if (termType.equalsIgnoreCase("MaxNumberOfOperation")) {
			val maxNumberOfOperation = tm as MaxNumberOfOperation

			if (maxNumberOfOperation.perTime !== null) {
				return termType + "ByTime" // MaxNumberOfOperationByTime
			}
			return termType // MaxNumberOfOperation
		} // ================================= MessageContent =================================
		else if (termType.equalsIgnoreCase("MessageContent")) {

			// 'MessageContent' '(' returnType= DataType ":" (content=STRING | variable=[Variable]) (comparisonOperator=ComparisonOperator expression=Expression ('per' timeUnit=TimeUnit)?)?  ')' 
			val messageContent = tm as MessageContent

			if (messageContent.expression === null) {
				// if (messageContent.content !== null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_onlyXPath_String" // MessageContent_onlyXPath_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_onlyXPath_Number" // MessageContent_onlyXPath_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_onlyXPath_Bollean" // MessageContent_onlyXPath_Boolean
				}
			} else if (messageContent.perTime === null) {
				if (messageContent.returnType === DataType.TEXT) {
					return termType + "_String" // MessageContent_String
				} else if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number" // MessageContent_Number
				} else if (messageContent.returnType === DataType.BOOLEAN) {
					return termType + "_Boolean" // MessageContent_Boolean
				}
			} else {
				if (messageContent.returnType === DataType.NUMERIC) {
					return termType + "_Number_PerTime" // MessageContent_Number_PerTime
				} else {
					return "//MessageContent_Number_PerTime is used only to numeric type"
				}
			}
		}
	}

	// ================================ BUILD THE STRUCT NAME USED IN SOLID EAI LIBRARY ============================
//	def static String getTermType(Variable variable) {
//		var type = getTermType(variable.term)
//		variables_map.put(variable.name, type)
//		return type
//	}
	// buildTheNameOfTheTermAsTheSolidityTermStructureName
	// ================================ General methods ============================
	def String contacStr(String str1, String str2) {
		return str1 + str2
	}

	def static insertNewValueInListIfDoesntExist(List<String> list, String value) {
		if (!list.contains(value)) {
			list.add(value)
		}
//		else{
//			println(value+" já existe na lista")
//		}
	}

	def static boolean isNumeric(String str) {
		try {
			Integer.parseInt(str)
			return true
		} catch (NumberFormatException e) {
			try {
				Double.parseDouble(str)
				return true
			} catch (NumberFormatException e1) {
				return false
			}
		}
	}

//	def static String subTypeTer(Term tm){
//		val subTypeTermName=""
//		
//		// MessageContent
//		// SessionInterval | WeekDaysInterval | TimeInterval | Timeout | MaxNumberOfOperation | MessageContent
//		return subTypeTermName
//		
//	}
}
//				Party «ct.application.name»;
//				Party «ct.process.name»;
//				«getTerms(ct.clauses.get(0).terms)»
//				
//				
//				event «ct.clauses.get(0).name+"event"»(string _logMessage);
//				
//				constructor(address _applicationWallet, address _processWallet){
//			    	«ct.application.name» = Party("«ct.process.name» ", _applicationWallet);
//				    «ct.process.name» = Party("«ct.process.name»", _processWallet);
//				}
//				
//				function «ct.clauses.get(0).name»(uint32 _accessDateTime, string memory _xPathContent, bool _xPathResult, address _performer) public returns(bool){
//								
//					
//					bool isBreached=false;
//					
//					if(«getConditionals(ct.clauses.get(0).terms)») {
//						operationLimit.requestsPerformed+=1;
//			        	return true;	
//					}
//					
//					emit «ct.clauses.get(0).name+"event"» ("Request made outside of allowed hours or distance limit exceeded");
//					return false;
//				}
//			}
//		'''
//	}
//
//	def getTS(String date){
//		return (Timestamp.valueOf(date).getTime()/1000);
//	}
//	
//	def getTerms(Terms term){
//		'''
//			«FOR c: term.eAllContents.toIterable»
//				«IF(c instanceof Timeout)»
//					Timeout public timeout = Timeout(«c.seconds», 0);
//				«ELSEIF(c instanceof WeekDaysInterval)»
//					WeekDaysInterval public weekDaysInterval = WeekDaysInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof TimeInterval)»
//					TimeInterval public timeInterval = TimeInterval(«c.start», «c.end»);
//				«ELSEIF(c instanceof MaxNumberOfOperation)»
//					MaxNumberOfOperation public maxNumberOfOperation = MaxNumberOfOperation(«c.operationsNumber», «c.timeUnit», 0, 0);
//				«ELSEIF(c instanceof MessageContent)»
//					MessageContent public messageContent = MessageContent("«c.content»");
//				«ENDIF»
//			«ENDFOR»
//		'''
//	}
//	
//	def getConditionals(Terms terms){
//		'''	
//		«FOR c: terms.eAllContents.toIterable»
//			«IF(c instanceof Timeout)»
//				!isTimeout(_accessDateTime, timeout.endTime) &&
//			«ELSEIF(c instanceof WeekDaysInterval)»
//				isBusinessDay(_accessDateTime, businessDay) &&
//			«ELSEIF(c instanceof TimeInterval)»
//				isIntoTimeInterval(_accessDateTime, timeInterval) &&
//			«ELSEIF(c instanceof MaxNumberOfOperation)»
//				!isOperationLimitReached(_accessDateTime, operationLimit) &&
//			«ENDIF»
//		«ENDFOR»
//		'''
//}
